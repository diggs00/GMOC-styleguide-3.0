var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { component, GbdsElement, prop } from '../core';
import { MapsApiLoader } from '../utils/google-map-api-loader';
import { MapEvents } from '../models/google-map';
import * as mapUtils from '../utils/google-map-utils';
import MarkerClusterer from '@google/markerclustererplus';
let GoogleMap = class GoogleMap extends GbdsElement {
    constructor() {
        super();
        this._markers = [];
        this._markerListeners = [];
    }
    onInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.innerHTML = `<div class="gb-map"></div>`;
            const loaderOpts = this.getLoaderOptions();
            try {
                yield MapsApiLoader.load(loaderOpts);
                this.getLocation();
            }
            catch (error) {
                this.dispatchEvent(new CustomEvent(MapEvents.error, { detail: error }));
            }
        });
    }
    addClickSelectedListener(marker) {
        marker.addListener('click', () => {
            const previouslySelectedMarker = this._markers.filter(m => m.getIcon() === this.markerSelectedImage);
            if (previouslySelectedMarker.length > 0) {
                previouslySelectedMarker[0].setIcon(this.markerImage);
            }
            marker.setIcon(this.markerSelectedImage);
        });
    }
    dispatchGeoError(error) {
        this.dispatchEvent(new CustomEvent('geoError', {
            detail: {
                code: error.code,
                message: error.message,
            },
        }));
    }
    getLoaderOptions() {
        let loaderOpts;
        if (this.clientId) {
            loaderOpts = { clientId: this.clientId, channel: this.channel };
        }
        else if (this.apiKey) {
            loaderOpts = { apiKey: this.apiKey };
        }
        loaderOpts.region = this.region;
        loaderOpts.language = this.language;
        return loaderOpts;
    }
    getLocation() {
        const geoErrorHandler = (error) => {
            this.dispatchGeoError(error);
            const latLng = new google.maps.LatLng(0, 0);
            this.initMap(latLng, 1);
        };
        const geoSuccessHandler = (position) => {
            const latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);
            this.initMap(latLng, this.zoom || 10);
        };
        navigator.geolocation.getCurrentPosition(geoSuccessHandler, geoErrorHandler, { timeout: 1000 });
    }
    initMap(latLng, zoom) {
        this.map = new google.maps.Map(this.querySelector('.gb-map'), {
            center: latLng,
            mapTypeId: google.maps.MapTypeId.ROADMAP,
            zoom: zoom,
            mapTypeControl: false,
            streetViewControl: false,
        });
        if (this.cluster) {
            this.clusterer = new MarkerClusterer(this.map, null, {
                imagePath: this.clusterImagePath || 'https://brands.gm-cdn.com/gbds/images/google-maps/m',
            });
        }
        if (this.markers && this.markers.length > 0) {
            this.setMarkers(this.markers);
        }
    }
    configureMarkerIcons(m) {
        if (this.markerImage)
            m.setIcon(this.markerImage);
    }
    configureMarkerClickListeners(m) {
        if (this.markerImage && this.markerSelectedImage)
            this.addClickSelectedListener(m);
        m.addListener('click', () => this.dispatchEvent(new CustomEvent('markerSelected', { detail: m })));
        if (this.scrollToMarker) {
            this._markerListeners.push(mapUtils.addClickPanListener(m, this.map, this.scrollXOffset, this.scrollYOffset));
        }
    }
    updateMarkerListenerOffsets() {
        this._markerListeners.forEach(m => m.remove());
        this._markerListeners = [];
        this._markers.forEach(m => {
            this.configureMarkerClickListeners(m);
        });
    }
    updateMarkers() {
        if (this.map) {
            this.setMarkers(this.markers);
        }
    }
    addMarker(marker) {
        const bounds = mapUtils.extendBounds(this.map.getBounds(), marker);
        mapUtils.addMarkersToMap(marker, this.map, this.clusterer);
        this.configureMarkerIcons(marker);
        this.configureMarkerClickListeners(marker);
        this._markers.push(marker);
        this.map.fitBounds(bounds);
    }
    clearMarkers() {
        if (this.clusterer) {
            mapUtils.clearMarkersFromMap(this.clusterer);
        }
        else {
            mapUtils.clearMarkersFromMap(this._markers);
        }
        this._markers = [];
        this._markerListeners = [];
    }
    getAllMarkers() {
        return this._markers;
    }
    getMarker(position) {
        return this._markers.find(m => {
            const mPosition = m.getPosition();
            return mPosition.equals(position);
        });
    }
    setMarkers(markers) {
        this.clearMarkers();
        const markersToAdd = markers[0].getPosition
            ? markers
            : markers.map(mapUtils.createMarker);
        mapUtils.addMarkersToMap(markersToAdd, this.map, this.clusterer);
        markersToAdd.forEach(m => {
            this.configureMarkerIcons(m);
            this.configureMarkerClickListeners(m);
        });
        const bounds = mapUtils.extendBounds(new google.maps.LatLngBounds(), markersToAdd);
        this._markers = markersToAdd;
        this.map.fitBounds(bounds);
    }
};
__decorate([
    prop()
], GoogleMap.prototype, "apiKey", void 0);
__decorate([
    prop()
], GoogleMap.prototype, "channel", void 0);
__decorate([
    prop()
], GoogleMap.prototype, "clientId", void 0);
__decorate([
    prop('boolean')
], GoogleMap.prototype, "cluster", void 0);
__decorate([
    prop()
], GoogleMap.prototype, "clusterImagePath", void 0);
__decorate([
    prop()
], GoogleMap.prototype, "language", void 0);
__decorate([
    prop()
], GoogleMap.prototype, "markerImage", void 0);
__decorate([
    prop()
], GoogleMap.prototype, "markerSelectedImage", void 0);
__decorate([
    prop()
], GoogleMap.prototype, "region", void 0);
__decorate([
    prop('boolean')
], GoogleMap.prototype, "scrollToMarker", void 0);
__decorate([
    prop('number')
], GoogleMap.prototype, "zoom", void 0);
__decorate([
    prop('array', 'updateMarkers')
], GoogleMap.prototype, "markers", void 0);
__decorate([
    prop('number', 'updateMarkerListenerOffsets')
], GoogleMap.prototype, "scrollXOffset", void 0);
__decorate([
    prop('number', 'updateMarkerListenerOffsets')
], GoogleMap.prototype, "scrollYOffset", void 0);
GoogleMap = __decorate([
    component('gb-google-map')
], GoogleMap);
export { GoogleMap };
