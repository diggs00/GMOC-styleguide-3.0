var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { component, GbdsElement, prop } from '../core';
import { MapsApiLoader } from '../utils/google-map-api-loader';
import { MapEvents } from '../models/google-map';
import * as mapUtils from '../utils/google-map-utils';
import MarkerClusterer from '@google/markerclustererplus';
let GoogleMap = class GoogleMap extends GbdsElement {
    constructor() {
        super();
        this._centerOfWorld = { lat: 0, lng: 0 };
        this._defaultZoom = 10;
        this._markers = [];
        this._markerListeners = [];
    }
    onInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.innerHTML = `<div class="gb-map"></div>`;
            const loaderOpts = this._getLoaderOptions();
            try {
                yield MapsApiLoader.load(loaderOpts);
                this._geocoder = new google.maps.Geocoder();
                yield this._getLocation(this.prompt);
            }
            catch (error) {
                this.dispatchEvent(new CustomEvent(MapEvents.error, { detail: error }));
            }
        });
    }
    _addClickSelectedListener(marker) {
        marker.addListener('click', () => {
            const previouslySelectedMarker = this._markers.filter(m => m.getIcon() === this.markerSelectedImage);
            if (previouslySelectedMarker.length > 0) {
                previouslySelectedMarker[0].setIcon(this.markerImage);
            }
            marker.setIcon(this.markerSelectedImage);
        });
    }
    _dispatchGeoError(error) {
        this.dispatchEvent(new CustomEvent('geoError', {
            detail: {
                code: error.code,
                message: error.message,
            },
        }));
    }
    _getLoaderOptions() {
        const loaderOpts = { clientId: this.clientId, channel: this.channel };
        loaderOpts.region = this.region;
        loaderOpts.language = this.language;
        return loaderOpts;
    }
    _getLocation(prompt) {
        return __awaiter(this, void 0, void 0, function* () {
            const geoErrorHandler = (error) => __awaiter(this, void 0, void 0, function* () {
                this._dispatchGeoError(error);
                yield this._initFromGeocodedLocation();
            });
            const geoSuccessHandler = (position) => {
                const latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);
                this._initMap(latLng, this._zoom);
            };
            if (prompt) {
                navigator.geolocation.getCurrentPosition(geoSuccessHandler, geoErrorHandler, { timeout: 1000 });
            }
            else {
                yield this._initFromGeocodedLocation();
            }
        });
    }
    _initFromGeocodedLocation() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const geocodedLocation = yield this.geocodeLocation(this.defaultMapLocation);
                this._initMap(geocodedLocation.geometry.location, this._zoom);
            }
            catch (error) {
                this._initMap(this._centerOfWorld, this._zoom);
            }
        });
    }
    _initMap(latLng, zoom) {
        this._map = new google.maps.Map(this.querySelector('.gb-map'), {
            center: latLng,
            mapTypeId: google.maps.MapTypeId.ROADMAP,
            zoom: zoom,
            mapTypeControl: false,
            streetViewControl: false,
            zoomControlOptions: {
                position: this.zoomControlPosition,
            },
            fullscreenControlOptions: {
                position: this.fullScreenControlPosition
            },
        });
        if (this.cluster)
            this._initializeCluster();
        if (this.markers && this.markers.length > 0)
            this.setMarkers(this.markers);
        const myOverlay = new google.maps.OverlayView();
        myOverlay.draw = function () {
            this.getPanes().markerLayer.className = 'markerLayer';
        };
        myOverlay.setMap(this._map);
    }
    _initializeCluster() {
        this._clusterer = new MarkerClusterer(this._map, null, {
            imagePath: this.clusterImagePath || 'https://brands.gm-cdn.com/gbds/images/google-maps/m',
            clusterClass: 'gb-map-cluster',
            styles: [
                {
                    url: this.clusterImagePath,
                    height: 45,
                    width: 45,
                },
            ],
        });
    }
    _configureMarkerIcons(m) {
        if (this.markerImage)
            m.setIcon(this.markerImage);
    }
    _configureMarkerClickListeners(m) {
        if (this.markerImage && this.markerSelectedImage)
            this._addClickSelectedListener(m);
        m.addListener('click', () => this.dispatchEvent(new CustomEvent('markerSelected', { detail: m })));
        if (this.scrollToMarker) {
            this._markerListeners.push(mapUtils.addClickPanListener(m, this._map, this.scrollXOffset, this.scrollYOffset));
        }
    }
    _updateMarkerListenerOffsets() {
        this._markerListeners.forEach(m => m.remove());
        this._markerListeners = [];
        this._markers.forEach(m => {
            this._configureMarkerClickListeners(m);
        });
    }
    _updateMarkers() {
        if (this._map) {
            this.setMarkers(this.markers);
        }
    }
    get _zoom() {
        var _a;
        return (_a = this.zoom) !== null && _a !== void 0 ? _a : this._defaultZoom;
    }
    addMarker(marker) {
        const bounds = mapUtils.extendBounds(this._map.getBounds(), marker);
        mapUtils.addMarkersToMap(marker, this._map, this._clusterer);
        this._configureMarkerIcons(marker);
        this._configureMarkerClickListeners(marker);
        this._markers.push(marker);
        this._map.fitBounds(bounds);
    }
    clearMarkers() {
        if (this._clusterer) {
            mapUtils.clearMarkersFromMap(this._clusterer);
        }
        else {
            mapUtils.clearMarkersFromMap(this._markers);
        }
        this._markers = [];
        this._markerListeners = [];
    }
    geocodeLocation(location, region) {
        return new Promise((resolve, reject) => {
            const geocoderRequest = mapUtils.isLatLngOrLiteral(location)
                ? { location: location }
                : { address: location, region: region || this.region };
            this._geocoder.geocode(geocoderRequest, (result, status) => {
                if (status === google.maps.GeocoderStatus.OK) {
                    const geocodedLocation = result[0];
                    resolve(geocodedLocation);
                }
                else {
                    reject(status);
                }
            });
        });
    }
    getAllMarkers() {
        return this._markers;
    }
    getMarker(position) {
        return this._markers.find(m => {
            const mPosition = m.getPosition();
            return mPosition.equals(position);
        });
    }
    setMarkers(markers) {
        this.clearMarkers();
        const markersToAdd = markers[0].getPosition
            ? markers
            : markers.map(mapUtils.createMarker);
        mapUtils.addMarkersToMap(markersToAdd, this._map, this._clusterer);
        markersToAdd.forEach(m => {
            this._configureMarkerIcons(m);
            this._configureMarkerClickListeners(m);
        });
        const bounds = mapUtils.extendBounds(new google.maps.LatLngBounds(), markersToAdd);
        this._markers = markersToAdd;
        this._map.fitBounds(bounds);
    }
    resetMapBounds() {
        const bounds = mapUtils.extendBounds(new google.maps.LatLngBounds(), this._markers);
        this._map.fitBounds(bounds);
    }
    resetMapCenterAndZoom() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const geocodedLocation = yield this.geocodeLocation(this.defaultMapLocation);
                this.setCenterAndZoom(geocodedLocation.geometry.location, this._zoom);
            }
            catch (error) {
                this.setCenterAndZoom(this._centerOfWorld, this._zoom);
            }
        });
    }
    setCenterAndZoom(center, zoom) {
        this._map.setZoom(zoom);
        this._map.setCenter(center);
    }
    get center() {
        return this._map.getCenter();
    }
    get currentZoom() {
        return this._map.getZoom();
    }
};
__decorate([
    prop()
], GoogleMap.prototype, "channel", void 0);
__decorate([
    prop()
], GoogleMap.prototype, "clientId", void 0);
__decorate([
    prop('boolean')
], GoogleMap.prototype, "cluster", void 0);
__decorate([
    prop()
], GoogleMap.prototype, "clusterImagePath", void 0);
__decorate([
    prop()
], GoogleMap.prototype, "language", void 0);
__decorate([
    prop()
], GoogleMap.prototype, "markerImage", void 0);
__decorate([
    prop()
], GoogleMap.prototype, "markerSelectedImage", void 0);
__decorate([
    prop('boolean')
], GoogleMap.prototype, "prompt", void 0);
__decorate([
    prop()
], GoogleMap.prototype, "region", void 0);
__decorate([
    prop('boolean')
], GoogleMap.prototype, "scrollToMarker", void 0);
__decorate([
    prop()
], GoogleMap.prototype, "defaultMapLocation", void 0);
__decorate([
    prop('number')
], GoogleMap.prototype, "zoom", void 0);
__decorate([
    prop('array', '_updateMarkers')
], GoogleMap.prototype, "markers", void 0);
__decorate([
    prop('number', '_updateMarkerListenerOffsets')
], GoogleMap.prototype, "scrollXOffset", void 0);
__decorate([
    prop('number', '_updateMarkerListenerOffsets')
], GoogleMap.prototype, "scrollYOffset", void 0);
__decorate([
    prop('number')
], GoogleMap.prototype, "zoomControlPosition", void 0);
__decorate([
    prop('number')
], GoogleMap.prototype, "fullScreenControlPosition", void 0);
GoogleMap = __decorate([
    component('gb-google-map')
], GoogleMap);
export { GoogleMap };
